from tkinter import *
from multiprocessing.managers import Value
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

def matrix():
    class sprawdzanie:
        def masa1():
            while True:
                try:
                    val = float(input("Podaj masę m1: "))
                    if val>0:
                        return val
                    else:
                        print("wartość musi być dodatnia")
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def masa2():
            while True:
                try:
                    val = float(input("Podaj masę m2: "))
                    if val>0:
                        return val
                    else:
                        print("wartość musi być dodatnia")
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def dlugosc1():
            while True:
                try:
                    val = float(input("Podaj długość L1: "))
                    if val>0:
                        return val
                    else:
                        print("wartość musi być dodatnia")
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def dlugosc2():
            while True:
                try:
                    val = float(input("Podaj długość L2: "))
                    if val>0:
                        return val
                    else:
                        print("wartość musi być dodatnia")
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def kat1():
            while True:
                try:
                    val = float(input("Podaj wychylenie pierwszego wahadła: "))
                    return val
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def kat2():
            while True:
                try:
                    val = float(input("Podaj wychylenie drugiego wahadła: "))
                    return val
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")

        def gravity():
            while True:
                try:
                    val = float(input("Podaj siłę grawitacji: "))
                    if val>0:
                        return val
                    else:
                        print("wartość musi być dodatnia")
                except ValueError:
                    print("Wartość musi być liczbą. Podaj liczbę wiekszą od 0")


    #okres czasu to ile razy dt, dt jest w sekundach
    def liczenie_a(m1, m2, g, L1, L2, theta1, theta2, okres_czasu=100000, dt = 0.01):
        theta1 = np.radians(theta1)  
        theta2 = np.radians(theta2)
        omega1, omega2 = 0.0, 0.0
        theta1_wart, theta2_wart = [theta1], [theta2]
        x1_wart, x2_wart, y1_wart, y2_wart = [], [], [], []
        for i in range(okres_czasu):
            delta = theta2 - theta1
            mian1 = (m1 + m2) * L1 - m2 * L1 * np.cos(delta) ** 2
            mian2 = (L2 / L1) * mian1

            a1 = (m2 * L1 * omega1 ** 2 * np.sin(delta) * np.cos(delta) +
                  m2 * g * np.sin(theta2) * np.cos(delta) +
                  m2 * L2 * omega2 ** 2 * np.sin(delta) -
                  (m1 + m2) * g * np.sin(theta1)) / mian1

            a2 = (-m2 * L2 * omega2 ** 2 * np.sin(delta) * np.cos(delta) +
                  (m1 + m2) * g * np.sin(theta1) * np.cos(delta) -
                  (m1 + m2) * L1 * omega1 ** 2 * np.sin(delta) -
                  (m1 + m2) * g * np.sin(theta2)) / mian2
            omega1 += a1 * dt
            omega2 += a2 * dt
            theta1 += omega1 * dt
            theta2 += omega2 * dt
            x1 = L1*np.sin(theta1)
            y1 = -L1*np.cos(theta1)
            x2 = x1 + L2*np.sin(theta2)
            y2 = y1-L2*np.cos(theta2)
        
            x1_wart.append(x1)
            x2_wart.append(x2)
            y1_wart.append(y1)
            y2_wart.append(y2)
        
            theta1_wart.append(theta1)
            theta2_wart.append(theta2)

        return x1_wart, x2_wart, y1_wart, y2_wart
    
    def calculate():
        try:
            m1_value = float(m1.get())
            m2_value = float(m2.get())
            g_value = float(g.get())
            L1_value = float(L1.get())
            L2_value = float(L2.get())
            theta1_value = float(theta1.get())
            theta2_value = float(theta2.get())
            x1, x2, y1, y2 = liczenie_a(m1_value, m2_value, g_value, L1_value, L2_value, theta1_value, theta2_value)
            result_label.config(text=f"x1: {x1[-1]:.2f}, y1: {y1[-1]:.2f}, x2: {x2[-1]:.2f}, y2: {y2[-1]:.2f}")
        except ValueError:
            result_label.config(text="Proszę wprowadzić poprawne liczby.")

# Główne okno aplikacji
    wartosc = Tk()
    wartosc.title("Symulacja Podwójnego Wahadła")

    # Tworzenie pól wprowadzania i przycisków
    Label(wartosc, text="Masa 1 (m1):").grid(row=0, column=0)
    m1 = Entry(wartosc)
    m1.grid(row=0, column=1)
    Label(wartosc, text="Masa 2 (m2):").grid(row=1, column=0)
    m2 = Entry(wartosc)
    m2.grid(row=1, column=1)
    Label(wartosc, text="Długość 1 (L1):").grid(row=2, column=0)
    L1 = Entry(wartosc)
    L1.grid(row=2, column=1)
    Label(wartosc, text="Długość 2 (L2):").grid(row=3, column=0)
    L2 = Entry(wartosc)
    L2.grid(row=3, column=1)
    Label(wartosc, text="Kąt początkowy 1 (theta1):").grid(row=4, column=0)
    theta1 = Entry(wartosc)
    theta1.grid(row=4, column=1)
    Label(wartosc, text="Kąt początkowy 2 (theta2):").grid(row=5, column=0)
    theta2 = Entry(wartosc)
    theta2.grid(row=5, column=1)
    Label(wartosc, text="Przyspieszenie grawitacyjne (g):").grid(row=6, column=0)
    g = Entry(wartosc)
    g.grid(row=6, column=1)

    # Przycisk zatwierdzający
    klik = Button(wartosc, text="Zatwierdź", command=calculate)
    klik.grid(row=7, columnspan=2)

    # Pole na wynik
    result_label = Label(wartosc, text="")
    result_label.grid(row=8, columnspan=2)

    wartosc.mainloop()

    x1, x2, y1, y2 = liczenie_a(m1, m2, g, L1, L2, theta1, theta2)

    fig, ax = plt.subplots()
    ax.set_xlim(-L1-L2-1,L1+L2+1)
    ax.set_ylim(-L1-L2-1,L1+L2+1)
    linia, = ax.plot([], [], 'o-', lw=2) #musi byc przecinek bo linia, tworzy obj Line2D używany w matplitlib i funcanim - bez "," tworzy sie lista a nie obj do animacji
    trajektoria, = ax.plot([], [], 'r-', lw=0.5, alpha=0.5)

    def init():
        linia.set_data([], [])
        trajektoria.set_data([], [])
        return linia, trajektoria

    def update(frame):
        x = [0, x1[frame], x2[frame]]
        y = [0, y1[frame], y2[frame]]
        linia.set_data(x, y)
        trajektoria.set_data(x2[:frame], y2[:frame])
        return linia, trajektoria

    ani = FuncAnimation(fig, update, frames=len(x1), init_func=init, blit=True, interval=0.001)

    plt.show()

master = Tk()
przycisk = Button(master, text="Start", command=matrix)
przycisk.pack()
mainloop()
